<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MPP Style Piano with Note Trails</title>
<style>
  body {
    background: #121212;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    user-select: none;
    overflow: hidden;
  }
  #piano {
    position: relative;
    width: 1400px;
    height: 280px;
    border: 2px solid #444;
    border-radius: 6px;
    box-shadow: 0 0 15px #0af;
    background: linear-gradient(180deg, #222 0%, #111 100%);
  }
  .white-key {
    position: relative;
    width: 40px;
    height: 280px;
    background: white;
    border: 1px solid #ccc;
    float: left;
    box-sizing: border-box;
    border-radius: 0 0 8px 8px;
    cursor: pointer;
    z-index: 1;
    transition: background 0.15s ease;
  }
  .white-key:active,
  .white-key.pressed {
    background: #aaf;
  }
  .black-key {
    position: absolute;
    width: 28px;
    height: 180px;
    background: black;
    border-radius: 0 0 6px 6px;
    border: 1px solid #222;
    top: 0;
    cursor: pointer;
    z-index: 2;
    transition: background 0.15s ease;
  }
  .black-key:active,
  .black-key.pressed {
    background: #66f;
  }
  /* Positions of black keys relative to white keys */
  /* Pattern repeats every 12 keys (octave) */
</style>
</head>
<body>
  <div id="piano"></div>

<script>
(() => {
  const piano = document.getElementById('piano');
  const whiteKeyWidth = 40;
  const blackKeyWidth = 28;
  const whiteKeyHeight = 280;
  const blackKeyHeight = 180;

  // Notes for 88-key piano from A0 to C8
  // Using standard piano key order with sharps/flats (#)
  // We'll assign notes with their key indices
  const keysPattern = [
    'A0','A#0','B0',
    'C1','C#1','D1','D#1','E1','F1','F#1','G1','G#1','A1','A#1','B1',
    'C2','C#2','D2','D#2','E2','F2','F#2','G2','G#2','A2','A#2','B2',
    'C3','C#3','D3','D#3','E3','F3','F#3','G3','G#3','A3','A#3','B3',
    'C4','C#4','D4','D#4','E4','F4','F#4','G4','G#4','A4','A#4','B4',
    'C5','C#5','D5','D#5','E5','F5','F#5','G5','G#5','A5','A#5','B5',
    'C6','C#6','D6','D#6','E6','F6','F#6','G6','G#6','A6','A#6','B6',
    'C7','C#7','D7','D#7','E7','F7','F#7','G7','G#7','A7','A#7','B7',
    'C8'
  ];

  // But we only want to make keys visually and logically, so it's easier to generate white and black keys by pattern:
  // White keys pattern (per octave): C, D, E, F, G, A, B
  // Black keys pattern (per octave): C#, D#, F#, G#, A#

  // For 88-key piano, starting from A0 up to C8, 52 white keys, 36 black keys total

  // To simplify, generate white keys first, then position black keys absolutely over them.

  // White keys count = 52
  const whiteKeys = [];
  // Black keys info: position relative to white keys (index), name
  // We'll track black key positions to set left CSS

  // Pattern of white keys in an octave (7 white keys):
  const whiteKeyNames = ['A','B','C','D','E','F','G'];
  // But starting from A0 we have 3 white keys in octave 0: A0, B0, then C1...

  // For a proper layout:
  // The piano starts at A0 (white key), then B0 (white), then C1 (white), and so on.
  // Let's generate all white keys and assign their notes accordingly.

  // Because black keys are positioned relative to white keys, let's track white keys with their indices

  // The pattern of black keys in an octave relative to white keys:
  // black keys appear after C, D, F, G, A white keys
  // So black keys go between these white keys:
  // Between C-D: C#
  // Between D-E: D#
  // Between F-G: F#
  // Between G-A: G#
  // Between A-B: A#

  // Let's create a helper to identify black keys and white keys along the 88 keys:

  // We'll create arrays of notes and also build the keyboard visually.

  // Helper arrays for the notes in octave (12 keys)
  const octaveNotes = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];

  // The full 88 key notes starting at A0:
  // Index 0 = A0
  // We'll build the notes array for all 88 keys:
  const allKeys = [];

  // Function to generate all keys notes for 88 keys:
  function generateKeys() {
    // Start octave 0 from A0
    // Octave 0 has keys from A0, A#0, B0 (3 keys)
    allKeys.push('A0', 'A#0', 'B0');
    // Then octaves 1 to 7 (12 keys per octave)
    for (let octave = 1; octave <= 7; octave++) {
      for (let i = 0; i < 12; i++) {
        allKeys.push(octaveNotes[i] + octave);
      }
    }
    // Then last key: C8
    allKeys.push('C8');
  }
  generateKeys();

  // Identify white and black keys in allKeys
  // White keys: notes without #
  // Black keys: notes with #

  // Create piano keys DOM
  let whiteKeyCount = 0;
  for (let i = 0; i < allKeys.length; i++) {
    const note = allKeys[i];
    const isBlack = note.includes('#');
    if (!isBlack) {
      // Create white key
      const wkey = document.createElement('div');
      wkey.classList.add('white-key');
      wkey.dataset.note = note;
      wkey.style.left = (whiteKeyCount * whiteKeyWidth) + 'px';
      wkey.style.position = 'absolute';
      piano.appendChild(wkey);
      whiteKeys.push(wkey);
      whiteKeyCount++;
    }
  }
  piano.style.width = (whiteKeyCount * whiteKeyWidth) + 'px';

  // Now position black keys
  // For black keys, they appear between specific white keys.
  // We need to find index of the white key that the black key comes after, then position black key halfway between them.

  // Map from note name to white key index for positioning
  const whiteNoteIndices = {};
  whiteKeys.forEach((wkey, idx) => {
    whiteNoteIndices[wkey.dataset.note] = idx;
  });

  for (let i = 0; i < allKeys.length; i++) {
    const note = allKeys[i];
    if (note.includes('#')) {
      // Black key
      // Find base note (remove #) and octave
      const baseNote = note[0]; // C, D, F, G, A
      const octave = note.slice(note.length - 1);
      // black keys come after C, D, F, G, A white keys
      // So find white keys with name baseNote + octave or the closest white key before the black key

      // Find white keys that the black key belongs to:

      // Due to octave changes for A0 and B0, sometimes the octave number differs:
      // We'll search in whiteKeys for note matching baseNote + octave or baseNote + (octave-1)

      // Because black keys are between white keys, position black key halfway

      // Find the white key index to position black key at left + whiteKeyWidth - blackKeyWidth/2

      // Find the white key immediately before black key

      // Strategy: find white key index with note baseNote + octave (or previous octave if not found)

      let whiteKeyNote = baseNote + octave;
      let whiteIndex = whiteNoteIndices[whiteKeyNote];

      if (whiteIndex === undefined) {
        // try previous octave for A and B keys (special cases)
        const prevOctave = (parseInt(octave) - 1).toString();
        whiteKeyNote = baseNote + prevOctave;
        whiteIndex = whiteNoteIndices[whiteKeyNote];
      }

      if (whiteIndex === undefined) {
        // fallback to nearest white key before black key
        whiteIndex = 0;
      }

      // Create black key div
      const bkey = document.createElement('div');
      bkey.classList.add('black-key');
      bkey.dataset.note = note;

      // Position black key absolutely
      // Place it roughly at whiteKey left + whiteKeyWidth - blackKeyWidth/2
      bkey.style.left = (whiteIndex * whiteKeyWidth + whiteKeyWidth - blackKeyWidth / 2) + 'px';
      bkey.style.top = '0px';
      piano.appendChild(bkey);
    }
  }

  // Now piano keys created! Add event listeners for press/release

  // Audio context setup (optional: you can connect sounds here)
  const AudioContext = window.AudioContext || window.webkitAudioContext;
  const audioCtx = new AudioContext();

  // Simple sine oscillator sound for demo (optional)
  function playNote(freq) {
    const osc = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);
    osc.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.5);
  }

  // Map notes to frequencies (A4=440Hz)
  // Formula: freq = 440 * 2^((n-49)/12), where n = key number (A0=1)
  // Let's map allKeys to frequencies:
  const A4Index = allKeys.indexOf('A4') + 1;
  const noteFrequencies = {};
  for (let i = 0; i < allKeys.length; i++) {
    const keyNum = i + 1;
    const freq = 440 * Math.pow(2, (keyNum - A4Index) / 12);
    noteFrequencies[allKeys[i]] = freq;
  }

  // Note trail particle effect container
  const effectContainer = document.createElement('div');
  effectContainer.style.position = 'absolute';
  effectContainer.style.top = '0';
  effectContainer.style.left = '0';
  effectContainer.style.width = '100%';
  effectContainer.style.height = '100%';
  effectContainer.style.pointerEvents = 'none';
  piano.appendChild(effectContainer);

  // Utility function: generate random pastel color from note
  function noteColor(note) {
    // Map note name to a consistent color hue
    // Use note letter + octave to generate a hue
    // Simple hash:
    const letters = 'CDEFGAB';
    let letter = note[0];
    let octave = parseInt(note.slice(note.length - 1)) || 4;
    let letterIndex = letters.indexOf(letter);
    let hue = ((letterIndex + octave) * 40) % 360;
    return `hsl(${hue}, 80%, 70%)`;
  }

  // Particle class for note trail
  class NoteParticle {
    constructor(x, y, color) {
      this.x = x;
      this.y = y;
      this.color = color;
      this.alpha = 1;
      this.size = 14 + Math.random() * 8;
      this.speedY = 1 + Math.random() * 1.5;
      this.element = document.createElement('div');
      this.element.style.position = 'absolute';
      this.element.style.borderRadius = '50%';
      this.element.style.background = color;
      this.element.style.opacity = this.alpha;
      this.element.style.pointerEvents = 'none';
      this.element.style.left = `${this.x}px`;
      this.element.style.top = `${this.y}px`;
      this.element.style.width = `${this.size}px`;
      this.element.style.height = `${this.size}px`;
      this.element.style.filter = 'drop-shadow(0 0 6px ' + color + ')';
      effectContainer.appendChild(this.element);
    }
    update() {
      this.y -= this.speedY;
      this.alpha -= 0.02;
      if (this.alpha < 0) this.alpha = 0;
      this.size *= 0.96;
      this.element.style.top = `${this.y}px`;
      this.element.style.opacity = this.alpha;
      this.element.style.width = `${this.size}px`;
      this.element.style.height = `${this.size}px`;
    }
    isDead() {
      return this.alpha <= 0;
    }
    remove() {
      this.element.remove();
    }
  }

  let particles = [];

  // Update loop for particles
  function animate() {
    particles.forEach((p, i) => {
      p.update();
      if (p.isDead()) {
        p.remove();
        particles.splice(i, 1);
      }
    });
    requestAnimationFrame(animate);
  }
  animate();

  // Key press handler
  function pressKey(keyDiv) {
    if (!keyDiv) return;
    if (keyDiv.classList.contains('pressed')) return; // already pressed
    keyDiv.classList.add('pressed');

    // Play sound
    const note = keyDiv.dataset.note;
    const freq = noteFrequencies[note];
    if (audioCtx.state === 'suspended') {
      audioCtx.resume();
    }
    playNote(freq);

    // Create note trail particles
    const rect = keyDiv.getBoundingClientRect();
    const pianoRect = piano.getBoundingClientRect();
    const x = rect.left - pianoRect.left + rect.width / 2;
    const y = rect.top - pianoRect.top + rect.height * 0.2;

    for (let i = 0; i < 6; i++) {
      const px = x + (Math.random() - 0.5) * 20;
      const py = y + (Math.random() - 0.5) * 10;
      const color = noteColor(note);
      const particle = new NoteParticle(px, py, color);
      particles.push(particle);
    }
  }

  // Key release handler
  function releaseKey(keyDiv) {
    if (!keyDiv) return;
    keyDiv.classList.remove('pressed');
  }

  // Mouse and touch event handlers
  function setupKeyEvents(keyDiv) {
    keyDiv.addEventListener('mousedown', e => {
      e.preventDefault();
      pressKey(keyDiv);
    });
    keyDiv.addEventListener('mouseup', e => {
      e.preventDefault();
      releaseKey(keyDiv);
    });
    keyDiv.addEventListener('mouseleave', e => {
      e.preventDefault();
      releaseKey(keyDiv);
    });
    keyDiv.addEventListener('touchstart', e => {
      e.preventDefault();
      pressKey(keyDiv);
    }, {passive:false});
    keyDiv.addEventListener('touchend', e => {
      e.preventDefault();
      releaseKey(keyDiv);
    });
  }

  // Attach events to all keys
  [...piano.querySelectorAll('.white-key, .black-key')].forEach(k => {
    setupKeyEvents(k);
  });
})();
</script>
</body>
</html>
